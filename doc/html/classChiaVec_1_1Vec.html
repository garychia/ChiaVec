<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChiaVec: ChiaVec::Vec&lt; T, Allocator, Storage &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChiaVec
   </div>
   <div id="projectbrief">ChiaVec is a powerful tool that offers sequence containers, namely Vec and CudaVec. Vec allocates memory on CPUs while CudaVec allocates memory on GPUs using CUDA. ChiaVec performs memory management across different processing units under the hood. This makes it easy for high-performance computing tasks using C++. C and Rust bindings are also provided.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ChiaVec</b></li><li class="navelem"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classChiaVec_1_1Vec-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ChiaVec::Vec&lt; T, Allocator, Storage &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A generic vector data structure that supports different memory allocators and storage types.  
 <a href="classChiaVec_1_1Vec.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vecs_8hpp_source.html">vecs.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1679f64c7444b1692c69ce80d22f6a23"><td class="memItemLeft" align="right" valign="top"><a id="a1679f64c7444b1692c69ce80d22f6a23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a1679f64c7444b1692c69ce80d22f6a23">Vec</a> ()</td></tr>
<tr class="memdesc:a1679f64c7444b1692c69ce80d22f6a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty vector. <br /></td></tr>
<tr class="separator:a1679f64c7444b1692c69ce80d22f6a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a53823914b760ef1ccc49127df6ef5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#ae6a53823914b760ef1ccc49127df6ef5">Vec</a> (std::size_t capacity)</td></tr>
<tr class="memdesc:ae6a53823914b760ef1ccc49127df6ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector with a specified initial capacity.  <a href="classChiaVec_1_1Vec.html#ae6a53823914b760ef1ccc49127df6ef5">More...</a><br /></td></tr>
<tr class="separator:ae6a53823914b760ef1ccc49127df6ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fffe134f9a95c7ca313f40357ebd208"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a5fffe134f9a95c7ca313f40357ebd208">Vec</a> (const T *data, std::size_t length, bool onHost)</td></tr>
<tr class="memdesc:a5fffe134f9a95c7ca313f40357ebd208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector from a raw data pointer and length.  <a href="classChiaVec_1_1Vec.html#a5fffe134f9a95c7ca313f40357ebd208">More...</a><br /></td></tr>
<tr class="separator:a5fffe134f9a95c7ca313f40357ebd208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec761b72f9188cd0ef5398d814298b09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#aec761b72f9188cd0ef5398d814298b09">Vec</a> (std::initializer_list&lt; T &gt; l)</td></tr>
<tr class="memdesc:aec761b72f9188cd0ef5398d814298b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector from an initializer list.  <a href="classChiaVec_1_1Vec.html#aec761b72f9188cd0ef5398d814298b09">More...</a><br /></td></tr>
<tr class="separator:aec761b72f9188cd0ef5398d814298b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389fdb43edde47bc6fd79156b057e72c"><td class="memTemplParams" colspan="2">template&lt;class OtherAllocator , class OtherStorage &gt; </td></tr>
<tr class="memitem:a389fdb43edde47bc6fd79156b057e72c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a389fdb43edde47bc6fd79156b057e72c">Vec</a> (const <a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, OtherAllocator, OtherStorage &gt; &amp;other)</td></tr>
<tr class="memdesc:a389fdb43edde47bc6fd79156b057e72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector from another vector.  <a href="classChiaVec_1_1Vec.html#a389fdb43edde47bc6fd79156b057e72c">More...</a><br /></td></tr>
<tr class="separator:a389fdb43edde47bc6fd79156b057e72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdf50e3fe7b450ea39b5576f03680e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#acfdf50e3fe7b450ea39b5576f03680e4">Vec</a> (<a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, Allocator, Storage &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:acfdf50e3fe7b450ea39b5576f03680e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classChiaVec_1_1Vec.html#acfdf50e3fe7b450ea39b5576f03680e4">More...</a><br /></td></tr>
<tr class="separator:acfdf50e3fe7b450ea39b5576f03680e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15912ae318821f04c6e576fddff4f180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, Allocator, Storage &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a15912ae318821f04c6e576fddff4f180">operator=</a> (const <a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, Allocator, Storage &gt; &amp;other)</td></tr>
<tr class="memdesc:a15912ae318821f04c6e576fddff4f180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classChiaVec_1_1Vec.html#a15912ae318821f04c6e576fddff4f180">More...</a><br /></td></tr>
<tr class="separator:a15912ae318821f04c6e576fddff4f180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa121e4e9b636f2192632a25989e83a2"><td class="memTemplParams" colspan="2">template&lt;class OtherAllocator , class OtherStorage &gt; </td></tr>
<tr class="memitem:afa121e4e9b636f2192632a25989e83a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, Allocator, Storage &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#afa121e4e9b636f2192632a25989e83a2">operator=</a> (const <a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, OtherAllocator, OtherStorage &gt; &amp;other)</td></tr>
<tr class="memdesc:afa121e4e9b636f2192632a25989e83a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for vectors with different allocators and storage types.  <a href="classChiaVec_1_1Vec.html#afa121e4e9b636f2192632a25989e83a2">More...</a><br /></td></tr>
<tr class="separator:afa121e4e9b636f2192632a25989e83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beb91851098b2dc48bc7cd49178a5df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, Allocator, Storage &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a6beb91851098b2dc48bc7cd49178a5df">operator=</a> (<a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, Allocator, Storage &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a6beb91851098b2dc48bc7cd49178a5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classChiaVec_1_1Vec.html#a6beb91851098b2dc48bc7cd49178a5df">More...</a><br /></td></tr>
<tr class="separator:a6beb91851098b2dc48bc7cd49178a5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2046a3b12e69bec4cc92ce73d2ec026"><td class="memItemLeft" align="right" valign="top">virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#ae2046a3b12e69bec4cc92ce73d2ec026">operator[]</a> (std::size_t index)</td></tr>
<tr class="memdesc:ae2046a3b12e69bec4cc92ce73d2ec026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at the specified index.  <a href="classChiaVec_1_1Vec.html#ae2046a3b12e69bec4cc92ce73d2ec026">More...</a><br /></td></tr>
<tr class="separator:ae2046a3b12e69bec4cc92ce73d2ec026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947bd20b410b9fca5f44b67a1cf0f62b"><td class="memItemLeft" align="right" valign="top">virtual const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a947bd20b410b9fca5f44b67a1cf0f62b">operator[]</a> (std::size_t index) const</td></tr>
<tr class="memdesc:a947bd20b410b9fca5f44b67a1cf0f62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at the specified index.  <a href="classChiaVec_1_1Vec.html#a947bd20b410b9fca5f44b67a1cf0f62b">More...</a><br /></td></tr>
<tr class="separator:a947bd20b410b9fca5f44b67a1cf0f62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3439cea781ad9d44c49c81257098f2b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#ad3439cea781ad9d44c49c81257098f2b">len</a> () const</td></tr>
<tr class="memdesc:ad3439cea781ad9d44c49c81257098f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length (number of elements) of the vector.  <a href="classChiaVec_1_1Vec.html#ad3439cea781ad9d44c49c81257098f2b">More...</a><br /></td></tr>
<tr class="separator:ad3439cea781ad9d44c49c81257098f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d41d6796ecafcc8a715206abfdb210c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a9d41d6796ecafcc8a715206abfdb210c">get</a> (std::size_t index)</td></tr>
<tr class="memdesc:a9d41d6796ecafcc8a715206abfdb210c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the element at the specified index.  <a href="classChiaVec_1_1Vec.html#a9d41d6796ecafcc8a715206abfdb210c">More...</a><br /></td></tr>
<tr class="separator:a9d41d6796ecafcc8a715206abfdb210c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9589c1646af0fc29e0e7f9286c498dba"><td class="memItemLeft" align="right" valign="top">std::optional&lt; const T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a9589c1646af0fc29e0e7f9286c498dba">getConst</a> (std::size_t index) const</td></tr>
<tr class="memdesc:a9589c1646af0fc29e0e7f9286c498dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a const pointer to the element at the specified index.  <a href="classChiaVec_1_1Vec.html#a9589c1646af0fc29e0e7f9286c498dba">More...</a><br /></td></tr>
<tr class="separator:a9589c1646af0fc29e0e7f9286c498dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f8c8df2ce53ebd8cba16c9fdae151c"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ae5f8c8df2ce53ebd8cba16c9fdae151c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#ae5f8c8df2ce53ebd8cba16c9fdae151c">push</a> (U &amp;&amp;element, bool onHost)</td></tr>
<tr class="memdesc:ae5f8c8df2ce53ebd8cba16c9fdae151c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the end of the vector.  <a href="classChiaVec_1_1Vec.html#ae5f8c8df2ce53ebd8cba16c9fdae151c">More...</a><br /></td></tr>
<tr class="separator:ae5f8c8df2ce53ebd8cba16c9fdae151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9efaac15c575c122db2c16979e5cd00"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#ae9efaac15c575c122db2c16979e5cd00">pop</a> ()</td></tr>
<tr class="memdesc:ae9efaac15c575c122db2c16979e5cd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the last element from the vector.  <a href="classChiaVec_1_1Vec.html#ae9efaac15c575c122db2c16979e5cd00">More...</a><br /></td></tr>
<tr class="separator:ae9efaac15c575c122db2c16979e5cd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d7af9f631b265e450024bef7fe3c54"><td class="memTemplParams" colspan="2">template&lt;class OtherAllocator , class OtherStorage &gt; </td></tr>
<tr class="memitem:a16d7af9f631b265e450024bef7fe3c54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a16d7af9f631b265e450024bef7fe3c54">copyTo</a> (<a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, OtherAllocator, OtherStorage &gt; &amp;vec) const</td></tr>
<tr class="memdesc:a16d7af9f631b265e450024bef7fe3c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of the current vector to another vector.  <a href="classChiaVec_1_1Vec.html#a16d7af9f631b265e450024bef7fe3c54">More...</a><br /></td></tr>
<tr class="separator:a16d7af9f631b265e450024bef7fe3c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b7a8f5fe1ebede52816ab83680a7a1"><td class="memTemplParams" colspan="2">template&lt;class OtherAllocator , class OtherStorage &gt; </td></tr>
<tr class="memitem:a22b7a8f5fe1ebede52816ab83680a7a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#a22b7a8f5fe1ebede52816ab83680a7a1">copyFrom</a> (const <a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, OtherAllocator, OtherStorage &gt; &amp;vec)</td></tr>
<tr class="memdesc:a22b7a8f5fe1ebede52816ab83680a7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of another vector to the current vector.  <a href="classChiaVec_1_1Vec.html#a22b7a8f5fe1ebede52816ab83680a7a1">More...</a><br /></td></tr>
<tr class="separator:a22b7a8f5fe1ebede52816ab83680a7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf790e0b7b01b49845d9557b7d2d38f"><td class="memTemplParams" colspan="2">template&lt;class OtherAllocator  = Memory::DefaultAllocator, class OtherStorage  = Raw::RawVec&lt;T, OtherAllocator&gt;&gt; </td></tr>
<tr class="memitem:afbf790e0b7b01b49845d9557b7d2d38f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, OtherAllocator, OtherStorage &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChiaVec_1_1Vec.html#afbf790e0b7b01b49845d9557b7d2d38f">clone</a> () const</td></tr>
<tr class="memdesc:afbf790e0b7b01b49845d9557b7d2d38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a deep copy of the current vector.  <a href="classChiaVec_1_1Vec.html#afbf790e0b7b01b49845d9557b7d2d38f">More...</a><br /></td></tr>
<tr class="separator:afbf790e0b7b01b49845d9557b7d2d38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3a77d925a0b6876c6781280abab27068"><td class="memTemplParams" colspan="2"><a id="a3a77d925a0b6876c6781280abab27068"></a>
template&lt;class U , class OtherAllocator , class OtherStorage &gt; </td></tr>
<tr class="memitem:a3a77d925a0b6876c6781280abab27068"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CudaVec</b></td></tr>
<tr class="separator:a3a77d925a0b6876c6781280abab27068"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Allocator = Memory::DefaultAllocator, class Storage = Raw::RawVec&lt;T, Allocator&gt;&gt;<br />
class ChiaVec::Vec&lt; T, Allocator, Storage &gt;</h3>

<p>A generic vector data structure that supports different memory allocators and storage types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements stored in the vector. </td></tr>
    <tr><td class="paramname">Allocator</td><td>The memory allocator used for the vector's storage. Defaults to <code><a class="el" href="structChiaVec_1_1Memory_1_1DefaultAllocator.html" title="Default memory allocator that allocates memory on the host (CPU).">Memory::DefaultAllocator</a></code>. </td></tr>
    <tr><td class="paramname">Storage</td><td>The storage type used for the vector's data. Defaults to <code><a class="el" href="classChiaVec_1_1Raw_1_1RawVec.html" title="A simple vector-like class that manages raw memory.">Raw::RawVec</a>&lt;T, Allocator&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae6a53823914b760ef1ccc49127df6ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a53823914b760ef1ccc49127df6ef5">&#9670;&nbsp;</a></span>Vec() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::<a class="el" href="classChiaVec_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a vector with a specified initial capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The initial capacity of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fffe134f9a95c7ca313f40357ebd208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fffe134f9a95c7ca313f40357ebd208">&#9670;&nbsp;</a></span>Vec() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::<a class="el" href="classChiaVec_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onHost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a vector from a raw data pointer and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The raw data pointer. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data. </td></tr>
    <tr><td class="paramname">onHost</td><td>Indicates whether the data is located on the host (true) or device (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec761b72f9188cd0ef5398d814298b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec761b72f9188cd0ef5398d814298b09">&#9670;&nbsp;</a></span>Vec() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::<a class="el" href="classChiaVec_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a vector from an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The initializer list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a389fdb43edde47bc6fd79156b057e72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389fdb43edde47bc6fd79156b057e72c">&#9670;&nbsp;</a></span>Vec() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherAllocator , class OtherStorage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::<a class="el" href="classChiaVec_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, OtherAllocator, OtherStorage &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a vector from another vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherAllocator</td><td>The memory allocator used for the other vector's storage. </td></tr>
    <tr><td class="paramname">OtherStorage</td><td>The storage type used for the other vector's data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfdf50e3fe7b450ea39b5576f03680e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdf50e3fe7b450ea39b5576f03680e4">&#9670;&nbsp;</a></span>Vec() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::<a class="el" href="classChiaVec_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, Allocator, Storage &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs a new vector by moving the contents of the <code>other</code> vector. After the construction, the <code>other</code> vector will be in a valid but unspecified state, and its length will be set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to move from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afbf790e0b7b01b49845d9557b7d2d38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf790e0b7b01b49845d9557b7d2d38f">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherAllocator  = Memory::DefaultAllocator, class OtherStorage  = Raw::RawVec&lt;T, OtherAllocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt;T, OtherAllocator, OtherStorage&gt; <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a deep copy of the current vector. </p>
<p>This function creates a new vector that is a deep copy of the current vector. The new vector can have a different allocator and storage type than the current vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherAllocator</td><td>The memory allocator to use for the new vector. </td></tr>
    <tr><td class="paramname">OtherStorage</td><td>The storage type to use for the new vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector that is a deep copy of the current vector. </dd></dl>

</div>
</div>
<a id="a22b7a8f5fe1ebede52816ab83680a7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b7a8f5fe1ebede52816ab83680a7a1">&#9670;&nbsp;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherAllocator , class OtherStorage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, OtherAllocator, OtherStorage &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of another vector to the current vector. </p>
<p>This function copies the contents of the <code>vec</code> vector to the current vector. The function performs a deep copy, where the underlying storage is also copied. After the copy operation, the current vector will have the same length and contents as the <code>vec</code> vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherAllocator</td><td>The memory allocator used for the <code>vec</code> vector. </td></tr>
    <tr><td class="paramname">OtherStorage</td><td>The storage type used for the <code>vec</code> vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to copy the contents from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16d7af9f631b265e450024bef7fe3c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d7af9f631b265e450024bef7fe3c54">&#9670;&nbsp;</a></span>copyTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherAllocator , class OtherStorage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, OtherAllocator, OtherStorage &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of the current vector to another vector. </p>
<p>This function copies the contents of the current vector to the <code>vec</code> vector, which may have a different allocator and storage type. The function performs a deep copy, where the underlying storage is also copied.</p>
<p>After the copy operation, the <code>vec</code> vector will have the same length as the current vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherAllocator</td><td>The memory allocator used for the <code>vec</code> vector. </td></tr>
    <tr><td class="paramname">OtherStorage</td><td>The storage type used for the <code>vec</code> vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to copy the contents to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d41d6796ecafcc8a715206abfdb210c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d41d6796ecafcc8a715206abfdb210c">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T *&gt; <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a pointer to the element at the specified index. </p>
<p>If the index is within the bounds of the vector, this function returns a <code>std::optional</code> containing a pointer to the element at the specified index. Otherwise, it returns a <code>std::nullopt</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::optional</code> containing a pointer to the element at the specified index, or <code>std::nullopt</code> if the index is out of bounds. </dd></dl>

</div>
</div>
<a id="a9589c1646af0fc29e0e7f9286c498dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9589c1646af0fc29e0e7f9286c498dba">&#9670;&nbsp;</a></span>getConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;const T *&gt; <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::getConst </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a const pointer to the element at the specified index. </p>
<p>If the index is within the bounds of the vector, this function returns a <code>std::optional</code> containing a const pointer to the element at the specified index. Otherwise, it returns a <code>std::nullopt</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::optional</code> containing a const pointer to the element at the specified index, or <code>std::nullopt</code> if the index is out of bounds. </dd></dl>

</div>
</div>
<a id="ad3439cea781ad9d44c49c81257098f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3439cea781ad9d44c49c81257098f2b">&#9670;&nbsp;</a></span>len()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::len </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length (number of elements) of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The length of the vector. </dd></dl>

</div>
</div>
<a id="a15912ae318821f04c6e576fddff4f180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15912ae318821f04c6e576fddff4f180">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt;T, Allocator, Storage&gt;&amp; <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, Allocator, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current vector after the assignment. </dd></dl>

</div>
</div>
<a id="afa121e4e9b636f2192632a25989e83a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa121e4e9b636f2192632a25989e83a2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherAllocator , class OtherStorage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt;T, Allocator, Storage&gt;&amp; <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, OtherAllocator, OtherStorage &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for vectors with different allocators and storage types. </p>
<p>Assigns the contents of the <code>other</code> vector to the current vector. This operation performs a deep copy, where the underlying storage is also copied.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherAllocator</td><td>The memory allocator used for the <code>other</code> vector. </td></tr>
    <tr><td class="paramname">OtherStorage</td><td>The storage type used for the <code>other</code> vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current vector after the assignment. </dd></dl>

</div>
</div>
<a id="a6beb91851098b2dc48bc7cd49178a5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6beb91851098b2dc48bc7cd49178a5df">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt;T, Allocator, Storage&gt;&amp; <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classChiaVec_1_1Vec.html">Vec</a>&lt; T, Allocator, Storage &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Moves the contents of the <code>other</code> vector to the current vector, effectively transferring ownership of the underlying storage. After the assignment, the <code>other</code> vector will be in a valid but unspecified state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current vector after the assignment. </dd></dl>

</div>
</div>
<a id="ae2046a3b12e69bec4cc92ce73d2ec026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2046a3b12e69bec4cc92ce73d2ec026">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T&amp; <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element. </dd></dl>

</div>
</div>
<a id="a947bd20b410b9fca5f44b67a1cf0f62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947bd20b410b9fca5f44b67a1cf0f62b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T&amp; <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element. </dd></dl>

</div>
</div>
<a id="ae9efaac15c575c122db2c16979e5cd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9efaac15c575c122db2c16979e5cd00">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt;T&gt; <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes and returns the last element from the vector. </p>
<p>This function removes and returns the last element from the vector. If the vector is empty, it returns <code>std::nullopt</code>.</p>
<p>If the allocator is configured to allocate on the host, the function directly returns the last element. Otherwise, it copies the last element to a temporary buffer and returns it.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::optional</code> containing the last element of the vector, or <code>std::nullopt</code> if the vector is empty. </dd></dl>

</div>
</div>
<a id="ae5f8c8df2ce53ebd8cba16c9fdae151c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f8c8df2ce53ebd8cba16c9fdae151c">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = Memory::DefaultAllocator, class Storage  = Raw::RawVec&lt;T, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChiaVec_1_1Vec.html">ChiaVec::Vec</a>&lt; T, Allocator, Storage &gt;::push </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onHost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new element to the end of the vector. </p>
<p>This function appends the given <code>element</code> to the end of the vector. If the vector's capacity needs to be increased to accommodate the new element, the function will automatically resize the underlying storage.</p>
<p>The <code>onHost</code> parameter specifies whether the <code>element</code> is located on the host (CPU) or the device (GPU). If <code>onHost</code> is true and the allocator is set to allocate on the host, the element is directly assigned to the vector's storage. Otherwise, the element is copied using the allocator's <code>copy()</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the element to be added. This type must be convertible to <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to be added to the vector. </td></tr>
    <tr><td class="paramname">onHost</td><td>Indicates whether the <code>element</code> is located on the host (CPU) or the device (GPU). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/include/<a class="el" href="vecs_8hpp_source.html">vecs.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
